# linux中的文件属性
## 文件属性rwx中r表示read (数字表示为4)、w表示write (数字表示为2)、x表示执行 (数字表示为1)。三个为一组，连续出现三次(如下面命令行中所示), 第一组表示文件的所有者拥有的权限，第二组为文件所有者所在的用户组所拥有的权限，组内所有成员都具有的权限，第三组为其它用户的权限。
chmod 可以修改文件或文件夹属性。
# 可执行属性
在linux中可以通过which查看文件在哪个路径下，which filename。which: 表示查看命令的路径。一般用于当我们想知道使用的命令来源于什么地方时，比如安装了多个R或多个python，但又分不清用的是哪个时，which一下
## linux是一个多用户系统，admin可以给不同的用户授予不同的文件权限，比如对文献的‘读，写，执行’
### chmod a+x file: 表示给文件增加所有人(a)可执行权限 (+x)
### chmod u+x file: 表示给文件增加所有者(u，user，)可执行权限 (+x)
### chmod g+x, chmod o+X: 表示给文件增加组内人或其它人可执行权限
### chmod 755 file: 表示拥有者有可读写执行权限，其它人有可读执行权限。(7=4+2+1; 5=4+1)
# PATH与path的区别
当我们在Terminal中输入一个命令，head，系统会在我们存放系统命令的目录中寻找手否有‘head’相关命令，进而运行。
## PATH: 是存放有(可执行)命令和程序的目录集合；在操作系统接到用户输入的命令时，会对PATH存储的目录进行查找，看下是否有与用户输入的命令同名的文件存在，而且是从前到后一个个查找，而且是查到就停，最后查不到就报错。（从这几个加粗的文字，可以看到操作系统很懒，当然懒是好的程序员的必备属性。）
通过以下命令查看PATH的路径
echo $PATH
/usr/bin:/usr/local/bin
在我们前面输入head命令时，操作系统收到回车指令后，先去看下$PATH里面有哪些目录，然后从第一个/usr/bin开始寻找，很幸运，一下找到了/usr/bin/head文件，尝试运行，成功。所以在这个情况下，我们输入head等同于输入/usr/bin/head。
如果自己写了一些脚本，那么该如何运行这些脚本呢
通过上述例子，只需要将存放有脚本文件的路径加入环境变量就可以了，例如我的脚本路径为‘/home/disk/project/database/pipeline.sh'，具体写法为
PATH=$PATH:/home/disk/project/database/pipeline.sh
加到环境变量的路径必须是全路径，全路径指以/开头或以~或${HOME}开头的路径 (注意：~开头的路径只能个人用户有效)。
有时我们也会看的这样的写法：export PATH=my_path:$PATH，这与export PATH=$PATH:my_path有什么区别呢？
回顾下这几个关键字：从前到后，查到就停。写出官话就是：PATH中越靠前的路径优先级越高。这有什么用处呢？
比如，一般的操作系统都会有系统的python和R，通常版本比较老，我们作为普通用户也没权限修改。
那怎么办？自己装一份新的python和R，然后用自己的，这时就涉及到优先级问题了。
假如我在/home/YSX/soft/anaconda/bin下安装了一个python，那么我需要设置优先调用我自己的python，设置环境变量时，我就得把/home/YSX/soft/anaconda/bin放到前面，如export PATH=/home/YSX/soft/anaconda/bin:$PATH。如果反过来写，那么/usr/bin/python就会优先被调用了。
# 长期使‘PATH’变量运行，只需要将上述的PATH变量写入~/.bash_profile
并且运行以下命令，使设置生效
source ~/.bash_profile
